<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Yigit's Blog</title>
        <link>https://yigitozkavci.github.io/blog</link>
        <description><![CDATA[Stuff about Haskell]]></description>
        <atom:link href="https://yigitozkavci.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 26 Jul 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>A type-safe advanced stack machine interface</title>
    <link>https://yigitozkavci.github.io/blog/posts/2018-07-26-a-type-safe-advanced-stack-machine-interface.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on July 26, 2018
        
            by Yiğit Özkavcı
        
    </section>
    <section>
        <h1 id="introduction">Introduction</h1>
<p>While developing <a href="https://github.com/cenary-lang/cenary/">Cenary</a>, a programming language for writing smart contracts, there were many places requiring an API for imperative stack machine procedures.</p>
<p>While generating code for procedural operations (say, a loop or branching), we need to somehow tame its imperative nature and bring safety, since we are equipped with Haskell.</p>
<p>In this post, we are going to achieve such behavior by introducing useful tools such as <strong>indexed monoids (categories)</strong>, <strong>RebindableSyntax</strong>, <strong>TypeApplications</strong> and so on.</p>
<h1 id="problem">Problem</h1>
<p>Let’s look at an example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">PUSH32 <span class="bn">0x3f</span>
PUSH32 <span class="bn">0x22</span>
MSTORE8 <span class="co">// Store the value 0x3f at memory address 0x22</span></code></pre></div>
<p>Imagine writing a code generator for this, it would look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">save ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Procedure</span>
save addr val <span class="fu">=</span> <span class="kw">do</span>
  push32 val
  push32 addr
  mstore</code></pre></div>
<p>This may look fine at first place, but both <code>val</code> and <code>addr</code> indicate that even though they are both <code>Int</code>s, actually they are quite different in meaning. We mean a pointer to an integer while saying <code>addr</code>, and a value integer for <code>val</code>.</p>
<p>Let’s look at another example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">broken ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Procedure</span>
broken val1 val2 <span class="fu">=</span> <span class="kw">do</span>
  push32 val1
  push32 val2
  pop
  pop
  pop</code></pre></div>
<p>Even by just looking at it, you saw the problem: we are making compiler allow us to pop from an empty stack. We can catch the error by using monads like Maybe or Either, but we want this kind of code not to compile at all.</p>
<h1 id="motivation">Motivation</h1>
<p>Eventually, in this post, we are aiming to achieve an api that would allow us a usage as such:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  generate <span class="fu">$</span> <span class="kw">do</span>
    push <span class="fu">@</span><span class="dt">IntPointer</span> <span class="dv">1</span> <span class="co">-- Push address to stack</span>
    push <span class="fu">@</span><span class="ch">&#39;IntVal 3    -- Push integer to stack</span>
    push <span class="fu">@</span><span class="ch">&#39;IntVal 5    -- Push integer to stack</span>
    push <span class="fu">@</span><span class="dt">IntPointer</span> <span class="dv">1</span> <span class="co">-- Push address to stack</span>
    mstore             <span class="co">-- Pop 2 items from stack</span>
    pop                <span class="co">-- Pop 1 items from stack</span>
    load               <span class="co">-- Pop 1 item from stack and push 1</span>
    pop                <span class="co">-- Pop 1 items from stack</span>
    <span class="kw">where</span>
      (<span class="fu">&gt;&gt;</span>) <span class="fu">=</span> (<span class="fu">Cat.&gt;&gt;&gt;</span>)</code></pre></div>
<p>Some assurances going on behind-the-scenes:</p>
<ul>
<li><p>We only allow <code>mstore</code> in generation of the code if top two items on the stack is in correct format (<code>s[0]</code> is an address, and <code>s[1]</code> is a value).</p></li>
<li><p>We are, obviously not allowing <code>pop</code>ping from an empty stack.</p></li>
<li><p>We only allow <code>load</code> instruction if <code>s[0]</code> (ie. the top element in stack) is a pointer, and we are putting its value to the stack. So a <code>IntPointer 1</code> is replaced by <code>IntVal 1</code> after load instruction is executed.</p></li>
</ul>
<p>These constraints are just the tip of the iceberg. Once we have the API, we can introduce many, possibly more sophisticated checks.</p>
<h1 id="implementation">Implementation</h1>
<h2 id="tools-required">Tools Required</h2>
<p>We begin with preparing the tools we are going to need.</p>
<p>First things first, we are going to need these extensions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeApplications #-}</span>
<span class="ot">{-# LANGUAGE RebindableSyntax #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre></div>
<p>A couple of EVM instructions. Even though it’s not needed to follow this post, if you are interested, there are <strong>many</strong> of them documented in the <a href="http://yellowpaper.io/">yellowpaper</a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EvmInstruction</span> <span class="fu">=</span>
    <span class="dt">PUSH</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">POP</span>
  <span class="fu">|</span> <span class="dt">LOAD</span>
  <span class="fu">|</span> <span class="dt">MSTORE8</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>And the tricky part. The type <code>Instr</code> represents an instruction in our API.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-</span>
<span class="co">   Meant to be used as a kind, so a type like &#39;Address (&#39;Address &#39;IntVal)</span>
<span class="co">   means a pointer to a pointer to an integer.</span>
<span class="co">-}</span>
<span class="kw">data</span> <span class="dt">ValueTy</span> <span class="fu">=</span> <span class="dt">IntVal</span>
            <span class="fu">|</span> <span class="dt">Address</span> <span class="dt">ValueTy</span>
            <span class="fu">|</span> <span class="dt">CharVal</span>

<span class="co">{-</span>
<span class="co">   `xs` is the stack before, and `ys` is after.</span>
<span class="co">   And in value level, it&#39;s just a modifier for stack full of `EvmInstruction`s.</span>
<span class="co">-}</span>
<span class="kw">newtype</span> <span class="dt">Instr</span> (<span class="ot">xs ::</span> [<span class="dt">ValueTy</span>]) (<span class="ot">ys ::</span> [<span class="dt">ValueTy</span>]) <span class="fu">=</span> <span class="dt">Instr</span>
  {<span class="ot"> _unInstr ::</span> [<span class="dt">EvmInstruction</span>] <span class="ot">-&gt;</span> [<span class="dt">EvmInstruction</span>]
  }

<span class="co">{-</span>
<span class="co">  And this is the essence to our API. We are propagating our</span>
<span class="co">  stack state at type level by binding instructions, given</span>
<span class="co">  that they tell us what kind of modification they do.</span>
<span class="co">-}</span>
<span class="kw">instance</span> <span class="dt">Cat.Category</span> <span class="dt">Instr</span> <span class="kw">where</span>

<span class="ot">  (.) ::</span> <span class="dt">Instr</span> b c <span class="ot">-&gt;</span> <span class="dt">Instr</span> a b <span class="ot">-&gt;</span> <span class="dt">Instr</span> a c
  <span class="dt">Instr</span> f1 <span class="fu">.</span> <span class="dt">Instr</span> f2 <span class="fu">=</span> <span class="dt">Instr</span> (f1 <span class="fu">.</span> f2)

<span class="ot">  id ::</span> <span class="dt">Instr</span> a a
  id <span class="fu">=</span> <span class="dt">Instr</span> id

  <span class="co">-- Laws</span>
  <span class="co">-- @</span>
  <span class="co">-- Instr f . id = Instr f</span>
  <span class="co">--</span>
  <span class="co">-- Proof:</span>
  <span class="co">-- Instr f . id = Instr f</span>
  <span class="co">-- Instr f . Instr id = Instr f</span>
  <span class="co">-- Instr (f . id) = Instr f</span>
  <span class="co">-- Instr f = Instr f</span>
  <span class="co">-- Qed</span>
  <span class="co">-- @</span></code></pre></div>
<h2 id="adding-instructions">Adding Instructions</h2>
<p>And finally, we are ready to describe our instructions. We basically encode instructions in two ways: one in type, and one in value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addInstr ::</span> <span class="dt">EvmInstruction</span> <span class="ot">-&gt;</span> <span class="dt">Instr</span> a b
addInstr i <span class="fu">=</span> <span class="dt">Instr</span> <span class="fu">$</span> (i<span class="fu">:</span>)

<span class="ot">push ::</span> forall elemTy xs<span class="fu">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Instr</span> xs (elemTy <span class="ch">&#39;: xs)</span>
push v <span class="fu">=</span> addInstr (<span class="dt">PUSH</span> v)

<span class="ot">pop ::</span> <span class="dt">Instr</span> (elemTy <span class="ch">&#39;: xs) xs</span>
pop <span class="fu">=</span> addInstr <span class="dt">POP</span>

<span class="ot">load ::</span> <span class="dt">Instr</span> (<span class="ch">&#39;Address elemTy &#39;</span><span class="fu">:</span> xs) (elemTy <span class="ch">&#39;: xs)</span>
load <span class="fu">=</span> addInstr <span class="dt">LOAD</span>

<span class="ot">mstore ::</span> <span class="dt">Instr</span> (<span class="ch">&#39;Address addr &#39;</span><span class="fu">:</span> valueTy <span class="ch">&#39;: xs) xs</span>
mstore <span class="fu">=</span> addInstr <span class="dt">MSTORE8</span></code></pre></div>
<h2 id="execution">Execution</h2>
<p>And finally, we are ready to write our code generator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generate ::</span> <span class="dt">Instr</span> <span class="ch">&#39;[] xs -&gt; IO ()</span>
generate <span class="fu">=</span> print <span class="fu">.</span> (<span class="fu">$</span> []) <span class="fu">.</span> _unInstr

<span class="kw">type</span> <span class="dt">IntPointer</span> <span class="fu">=</span> <span class="ch">&#39;Address &#39;</span><span class="dt">IntVal</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  generate <span class="fu">$</span> <span class="kw">do</span>
    push <span class="fu">@</span><span class="dt">IntPointer</span> <span class="bn">0x16</span>
    push <span class="fu">@</span><span class="ch">&#39;IntVal 3</span>
    push <span class="fu">@</span><span class="ch">&#39;IntVal 5</span>
    push <span class="fu">@</span><span class="dt">IntPointer</span> <span class="bn">0x24</span>
    mstore
    pop
    load
    pop
    <span class="kw">where</span>
      (<span class="fu">&gt;&gt;</span>) <span class="fu">=</span> (<span class="fu">Cat.&gt;&gt;&gt;</span>)</code></pre></div>
<p>Notice that we are telling push method what type to use for given integer when it’s pushed into the stack, we are making use of <code>TypeApplications</code> there.</p>
<h1 id="analysis">Analysis</h1>
<p>The following signature for <code>load</code> captures all the behavior of a <code>load</code> instruction:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">load ::</span> <span class="dt">Instr</span> (<span class="ch">&#39;Address elemTy &#39;</span><span class="fu">:</span> xs) (elemTy <span class="ch">&#39;: xs)</span></code></pre></div>
<p>Signature of the <code>load</code> instruction has something special as well, thanks to parametric polymorphism: whichever type you have in the pointer at the top of the stack, you have the value of that pointer. So if you have a <code>Address (Address Int)</code>, you get back an <code>Address Int</code> and this is powerful.</p>
<p>Now let’s look at the <code>mstore</code> generator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mstore ::</span> <span class="dt">Instr</span> (<span class="ch">&#39;Address addr &#39;</span><span class="fu">:</span> valueTy <span class="ch">&#39;: xs) xs</span></code></pre></div>
<p>It’s pattern matching on the state of the stack, so that it both ensures that there are at least 2 items, and type of the items are suitable for mstore instruction.</p>
<h1 id="conclusion">Conclusion</h1>
<p>There are many possible checks that can be done in compile time, and we are able to do it in an intuitive way.</p>
    </section>
</article>
]]></description>
    <pubDate>Thu, 26 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://yigitozkavci.github.io/blog/posts/2018-07-26-a-type-safe-advanced-stack-machine-interface.html</guid>
    <dc:creator>Yiğit Özkavcı</dc:creator>
</item>
<item>
    <title>Type safe xpath selectors by generating compile-time constraints</title>
    <link>https://yigitozkavci.github.io/blog/posts/2018-07-16-type-safe-xpath-selectors.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on July 16, 2018
        
            by Yiğit Özkavcı
        
    </section>
    <section>
        <p>In <a href="http://picussecurity.com/">Picus Security</a>, we use the <a href="https://hackage.haskell.org/package/webdriver">webdriver</a> library extensively for our Selenium end-to-end tests. The library itself is very convenient in terms of user API, but when it comes to actually debugging end to end test code, things aren’t quite smooth compared to just writing the tests.</p>
<p>The fact that Selenium needs to be told a timeout for failure cases makes it really hard to debug end to end tests, because we just need to stare at the screen for 1 minute / 5 minutes and wait for Selenium to show us the result of the test. This arises the question: can we actually make sure that our <strong>XPaths</strong> and <strong>actions</strong> make sense?</p>
<p>I’ve been working on a more strict version of <a href="https://hackage.haskell.org/package/webdriver">webdriver</a>, <a href="https://github.com/yigitozkavci/typed-webdriver">typed-webdriver</a>. It leverages TemplateHaskell to convert your xpath strings to well-kinded versions with associated capabilities, then it carries this information with constraints to other functions. This is quite confusing, so let’s jump to an example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds       #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Test.TWebDriver.Commands</span> (<span class="dt">Capability</span> (..), <span class="dt">Selector</span> (..), <span class="dt">WD</span>,
                                 click, findElem, mkXPath)

<span class="co">-- 1) Typechecks, because we try to click to a element of type link.</span>
<span class="ot">myS ::</span> <span class="dt">WD</span> ()
myS <span class="fu">=</span> click <span class="fu">=&lt;&lt;</span> myFindElem <span class="fu">$</span>(mkXPath <span class="st">&quot;//span/button/descendant::a[contains(text(), &#39;wow&#39;)]&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 2) Does not compile, because we try to click to a span element, which should not be clickable.</span>
<span class="ot">myS ::</span> <span class="dt">WD</span> ()
myS <span class="fu">=</span> click <span class="fu">=&lt;&lt;</span> myFindElem <span class="fu">$</span>(mkXPath <span class="st">&quot;//span/button/descendant::span[contains(text(), &#39;wow&#39;)]&quot;</span>)
<span class="co">{-</span>
<span class="co">  TypeError:</span>
<span class="co">  The following XPath is not clickable:</span>
<span class="co">  //a/button/descendant::span[contains(text(), &#39;wow&#39;)]</span>
<span class="co">-}</span></code></pre></div>
<p>If you are unfamiliar to XPath, here is what is happening:</p>
<ul>
<li><p>In case 1), we target an element like <code>&lt;span&gt;&lt;button&gt;&lt;a&gt;wowo&lt;/a&gt;&lt;/button&gt;&lt;/span&gt;</code>. Since an element with tag <code>a</code> is clickable, we allow calling <code>click</code> on <strong>elements found by this xpath</strong>.</p></li>
<li><p>In the case 2), however, we are targeting a <code>span</code> character and we very well know that we are not supposed to click on elements of tag <code>span</code>, hence we reject this code in compile-time. But… how?</p></li>
</ul>
<p>In order to reject a code in compile-time, we need to somehow make constraints and type-level assertions. One way to do this is to use a type-list of capabilities that a XPath selector has.</p>
<p>An example of what we produce in a call to <code>mkXPath</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XTemplateHaskell</span>
<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XDataKinds</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Language.Haskell.TH</span>
<span class="fu">&gt;</span>
<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="fu">$</span>(mkXPath <span class="st">&quot;//span/button/descendant::a[contains(text(), &#39;wow&#39;)]&quot;</span>)
<span class="fu">$</span>(mkXPath <span class="st">&quot;//span/button/descendant::a[contains(text(), &#39;wow&#39;)]&quot;</span>)
<span class="ot">  ::</span> <span class="dt">Selector</span>
       <span class="st">&quot;//span/button/descendant::a[contains(text(), &#39;wow&#39;)]&quot;</span>
       <span class="ch">&#39;[&#39;</span><span class="dt">Clickable</span>, <span class="ch">&#39;ContainsText]</span></code></pre></div>
<p>TemplateHaskell has its own constructors for Haskell types, values, functions, instances etc. And it’s very hard to try to memorize every construction, so we simply use the repl and type:</p>
<pre><code>&gt; runQ [e|Selector :: Selector &quot;yigit&quot;|]
SigE
  (ConE Test.TWebDriver.Commands.Selector)
  (AppT (ConT Test.TWebDriver.Commands.Selector) (LitT (StrTyLit &quot;yigit&quot;)))</code></pre>
<p>We cannot use this quasi quotation everywhere, but it still helps us understand how TemplateHaskell constructs values.</p>
<p>And here is the definition of <code>mkXPath</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkXPath ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
mkXPath name <span class="fu">=</span> <span class="kw">do</span>
  promotedTySig <span class="ot">&lt;-</span> toPromotedTH (generateCapabilities name)
  pure <span class="fu">$</span>
    <span class="dt">SigE</span>
      (<span class="dt">ConE</span> (mkName <span class="st">&quot;Selector&quot;</span>))
      (<span class="dt">AppT</span>
        (<span class="dt">AppT</span>
          (<span class="dt">ConT</span> (mkName <span class="st">&quot;Selector&quot;</span>))
          (<span class="dt">LitT</span> (<span class="dt">StrTyLit</span> name))
        )
        promotedTySig
      )

<span class="ot">toPromotedTH ::</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">Capability</span>] <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Type</span>
toPromotedTH (<span class="dt">Left</span> err) <span class="fu">=</span> reportError err <span class="fu">$&gt;</span> <span class="dt">PromotedNilT</span>
toPromotedTH (<span class="dt">Right</span> []) <span class="fu">=</span> pure <span class="dt">PromotedNilT</span>
toPromotedTH (<span class="dt">Right</span> (cap<span class="fu">:</span>xs)) <span class="fu">=</span> <span class="kw">do</span>
  deeper <span class="ot">&lt;-</span> toPromotedTH (<span class="dt">Right</span> xs)
  pure <span class="fu">$</span>
    <span class="dt">AppT</span>
      (<span class="dt">AppT</span>
        <span class="dt">PromotedConsT</span>
        (<span class="dt">PromotedT</span> (mkName (show cap)))
      )
      deeper</code></pre></div>
<p>So we basically create a type-level string for consuming xpath in “sending to Selenium” process, and also a list of capabilities this XPath has.</p>
<p>After creating our qualified selector, we need to be able to find elements with it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds             #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures        #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes            #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables   #-}</span>

<span class="kw">import qualified</span> <span class="dt">Test.WebDriver.Commands</span>    <span class="kw">as</span> <span class="dt">WDM</span>
<span class="kw">import qualified</span> <span class="dt">Test.WebDriver.Monad</span>       <span class="kw">as</span> <span class="dt">WDM</span>
<span class="kw">import           </span><span class="dt">GHC.TypeLits</span>               (<span class="dt">KnownSymbol</span>, <span class="dt">Symbol</span>, symbolVal)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span>                  <span class="kw">as</span> <span class="dt">T</span>

findElem
<span class="ot">  ::</span> forall name cap<span class="fu">.</span> <span class="dt">KnownSymbol</span> name
  <span class="ot">=&gt;</span> <span class="dt">Selector</span> name cap
  <span class="ot">-&gt;</span> <span class="dt">WDM.WD</span> (<span class="dt">Element</span> name cap)
findElem <span class="dt">Selector</span> <span class="fu">=</span> fmap <span class="dt">Element</span>
                  <span class="fu">$</span> WDM.findElem
                  <span class="fu">$</span> <span class="dt">WDM.ByXPath</span>
                  <span class="fu">$</span> T.pack
                  <span class="fu">$</span> symbolVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> name)</code></pre></div>
<p>The capabilities we have at type level are used by several library functions. For instance, let’s take a look at the signature of click function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Capability</span> <span class="fu">=</span>
    <span class="dt">Clickable</span>
  <span class="fu">|</span> <span class="dt">Hoverable</span>
  <span class="fu">|</span> <span class="dt">ContainsText</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> family <span class="dt">XPathNotClickableError</span> (<span class="ot">name ::</span> <span class="dt">Symbol</span>)<span class="ot"> ::</span> b <span class="kw">where</span>
  <span class="dt">XPathNotClickableError</span> name <span class="fu">=</span>
    <span class="dt">TypeError</span> ( <span class="ch">&#39;Text &quot;The following XPath is not clickable: &quot;</span>
          <span class="ch">&#39;:$$: &#39;</span><span class="dt">Text</span> name
    )

<span class="kw">type</span> family <span class="dt">CanClick</span> (<span class="ot">name ::</span> <span class="dt">Symbol</span>) (<span class="ot">xs ::</span> [<span class="dt">Capability</span>])<span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
  <span class="dt">CanClick</span> name <span class="ch">&#39;[] = XPathNotClickableError name</span>
  <span class="dt">CanClick</span> _ (<span class="ch">&#39;Clickable &#39;</span><span class="fu">:</span> xs) <span class="fu">=</span> ()
  <span class="dt">CanClick</span> name (x <span class="ch">&#39;: xs) = CanClick name xs</span>

<span class="ot">click ::</span> forall name xs<span class="fu">.</span> <span class="dt">CanClick</span> name xs <span class="ot">=&gt;</span> <span class="dt">Element</span> name xs <span class="ot">-&gt;</span> <span class="dt">WDM.WD</span> ()
click <span class="fu">=</span> WDM.click <span class="fu">.</span> unElement</code></pre></div>
<p>This way, after encoding necessary capabilities in a Selector’s type, we can observe what actions can be taken with this selector thgouhgout the journey of compilation.</p>
<p>This library is still in being developed, and not meant to be used in production yet.</p>
<p>The purpose of this blog post is to demonstrate how we can leverage lightweight usage of TemplateHaskell to generate compile-time constraints for us via regular Haskell expressions.</p>
<p>Cheers.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Thanks to Enis Bayramoğlu for long discussions on ways of improving usability of API</li>
</ul>
    </section>
</article>
]]></description>
    <pubDate>Mon, 16 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://yigitozkavci.github.io/blog/posts/2018-07-16-type-safe-xpath-selectors.html</guid>
    <dc:creator>Yiğit Özkavcı</dc:creator>
</item>
<item>
    <title>Jumping through instructions with RecursiveDo</title>
    <link>https://yigitozkavci.github.io/blog/posts/2018-06-11-recursive-do-jump.html</link>
    <description><![CDATA[<article>
    <section class="header">
        Posted on June 11, 2018
        
            by Yiğit Özkavcı
        
    </section>
    <section>
        <p>When we read a program written in any programming language, we implicitly assume that the state flows in the direction we read the code, at least inside functions. I had my mind blown when I first saw the <code>RevState</code> and <code>Tardis</code> monads; they break our assumption on the direction of the state flow. Since they are already interesting enough for one to dig deep into, in this post I won’t focus on them, instead, I will talk about an interesting real-world problem I encountered, and a solution that involves depending on a future value.</p>
<p>First, I will describe the problem of jumping through instructions, and then I will develop several solutions for it. The reader is assumed to have some basic familiarity with Haskell, at least up to a basic understanding of monads.</p>
<p>Imagine a simple virtual machine managed by a stack and memory. Let <code>u</code> denote the stack, and <code>u[i]</code> denote the ith element from the top in the stack. Consider having 6 kinds of instructions:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Push the given element into the stack so that u[0] = val</span>
<span class="co"># and all other values are pushed one level downwards</span>
<span class="ex">PUSH</span> val

<span class="co"># Add u[0] and u[1] then pop both of them and push the</span>
<span class="co"># result into the stack</span>
<span class="ex">ADD</span>

<span class="co"># Test and jump: jump to destination u[0] if (u[1] != 0)</span>
<span class="co"># and pop two elements from the stack</span>
<span class="ex">JUMPI</span>

<span class="co"># Apply not unary operator to the value u[0]</span>
<span class="co"># So if (u[0] == 1) before, now (u[0] == 0) and vice versa</span>
<span class="ex">NOT</span>

<span class="co"># Store the value u[0] into the address u[1]</span>
<span class="co"># and pop two elements from the stack</span>
<span class="ex">STORE</span>

<span class="co"># Marks a valid jump destination. All jumps</span>
<span class="co"># should be made onto a JUMPDEST instruction</span>
<span class="ex">JUMPDEST</span></code></pre></div>
<p>So if we were to convert an if statement to instructions;</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="cf">if</span>(predicate) {
  a = <span class="dv">3</span> + <span class="dv">5</span>;
}</code></pre></div>
<p>We would end up with the program below:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">1</span> PUSH predicate <span class="co"># Push if&#39;s condition expression</span>
<span class="ex">2</span> NOT <span class="co"># We will jump outside of if&#39;s body if the condition is NOT true</span>
<span class="ex">3</span> PUSH 10
<span class="ex">4</span> JUMPI
<span class="ex">5</span> PUSH 0xf4 <span class="co"># Arbitrary address for variable &quot;a&quot;</span>
<span class="ex">6</span> PUSH 5
<span class="ex">7</span> PUSH 3
<span class="ex">8</span> ADD
<span class="ex">9</span> STORE
<span class="ex">10</span> JUMPDEST <span class="co"># If statement&#39;s body is completed</span></code></pre></div>
<p>If we represent this computation in Haskell, it would look something like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import           </span><span class="dt">Data.Monoid</span> ((&lt;&gt;))

<span class="kw">data</span> <span class="dt">Instruction</span> <span class="fu">=</span>
    <span class="dt">NOT</span>
  <span class="fu">|</span> <span class="dt">PUSH</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">ADD</span>
  <span class="fu">|</span> <span class="dt">JUMPI</span>
  <span class="fu">|</span> <span class="dt">STORE</span>
  <span class="fu">|</span> <span class="dt">JUMPDEST</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">type</span> <span class="dt">InstructionSet</span> <span class="fu">=</span> [<span class="dt">Instruction</span>]

<span class="kw">data</span> <span class="dt">InstrState</span> <span class="fu">=</span> <span class="dt">InstrState</span>
  {<span class="ot"> _instrSet ::</span> <span class="dt">InstructionSet</span>
  ,<span class="ot"> _pc       ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">op ::</span> <span class="dt">Instruction</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">InstrState</span> ()
op instr <span class="fu">=</span>
  modify <span class="fu">$</span> \(<span class="dt">InstrState</span> set pc) <span class="ot">-&gt;</span> <span class="dt">InstrState</span> (set <span class="fu">&lt;&gt;</span> [instr]) (pc <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">ifBlock ::</span> <span class="dt">State</span> <span class="dt">InstrState</span> ()
ifBlock <span class="fu">=</span> <span class="kw">do</span>
  op (<span class="dt">PUSH</span> <span class="bn">0xf4</span>) <span class="co">-- An arbitrary address for variable a</span>
  op (<span class="dt">PUSH</span> <span class="dv">5</span>)
  op (<span class="dt">PUSH</span> <span class="dv">3</span>)
  op <span class="dt">ADD</span>
  op <span class="dt">STORE</span>

<span class="ot">compute ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">InstrState</span> ()
compute predicate <span class="fu">=</span> <span class="kw">do</span>
  op (<span class="dt">PUSH</span> predicate)
  op <span class="dt">NOT</span>
  op (<span class="dt">PUSH</span> <span class="dv">10</span>)
  op <span class="dt">JUMPI</span>
  ifBlock
  op <span class="dt">JUMPDEST</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> _instrSet <span class="fu">$</span> execState (compute <span class="dv">1</span>) (<span class="dt">InstrState</span> [] <span class="dv">0</span>)
<span class="co">-- Output:</span>
<span class="co">-- [PUSH 1,NOT,PUSH 10,JUMPI,PUSH 244,PUSH 5,PUSH 3,ADD,STORE,JUMPDEST]</span></code></pre></div>
<p>You may already have noticed that at instruction number 3, we’ve pushed 10; it’s nice to directly jump to your destination, but how did we know we had to jump to PC 10? The problem with this solution is that we need to know that we need to push 10 into stack before we know the total cost of theif statement’s body.</p>
<p>Even if in this case if statement’s body cost does not change, in the real world scenario it does according to the state of the variables &amp; lexical scope of the statement. One pattern to observe is that in some places, we implicitly depend on some future computation, which is <code>ifBlock</code> in this case. We need to somehow be able to say “give me the destination, but I don’t know its value yet, it will be computed later so wait for it”.</p>
<p>We could achieve this behavior within pure contexts thanks to let bindings in Haskell being lazy and recursive, but here, we are inside a monadic context under State monad. The correspondent of this lazy behavior for effectful computations is rec enabled by the <code>RecursiveDo</code> extension (you can develop an intuition for it <a href="https://ocharles.org.uk/blog/posts/2014-12-09-recursive-do.html">here</a>). So we modify our compute function to calculate jump destination before it arrives at that location:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecursiveDo #-}</span>
<span class="fu">...</span>
<span class="ot">jumpdest ::</span> <span class="dt">State</span> <span class="dt">InstrState</span> <span class="dt">Int</span>
jumpdest <span class="fu">=</span> <span class="kw">do</span>
  op <span class="dt">JUMPDEST</span>
  _pc <span class="fu">&lt;$&gt;</span> get

<span class="ot">compute ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">InstrState</span> ()
compute predicate <span class="fu">=</span> <span class="kw">do</span>
  op (<span class="dt">PUSH</span> predicate)
  op <span class="dt">NOT</span>
  rec op (<span class="dt">PUSH</span> dest)
      op <span class="dt">JUMPI</span>
      ifBlock
      dest <span class="ot">&lt;-</span> jumpdest
  pure ()
<span class="fu">...</span></code></pre></div>
<p>Thanks to lazy evaluation, <code>RecursiveDo</code> extension lets us declare that we want to use some value, but not necessarily compute it right now; most importantly, does it while preserving the effect order. This is important because even in our small use-case, we need the proper ordering of instructions.</p>
<p>There is a drawback here, though. If we were to care for optimization here, we would want our values to be strictly evaluated at the time we construct the instructions. You cannot simply strictly evaluate the destination value, so if we do the following change to <code>PUSH</code> constructor in order to force it to evaluate the Int value it takes right at construction time:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Instruction</span> <span class="fu">=</span>
<span class="fu">...</span>
 <span class="fu">|</span> <span class="dt">PUSH</span> <span class="fu">!</span><span class="dt">Int</span>
<span class="fu">...</span> </code></pre></div>
<p>… nothing changes! Why? Let’s look at the definition of op function. It takes the instruction as an argument, but it’s a thunk at that time. Haskell does not evaluate the <code>PUSH !Int</code>, so it cannot evaluate <code>!Int</code> part at all! In order to observe what happens in the case of strict evaluation, we need the strictness operator also on instr parameter of <code>op</code> function. Remember that <code>BangPatterns</code> extension is required for this task:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="fu">...</span>
<span class="ot">op ::</span> <span class="dt">Instruction</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">InstrState</span> ()
op <span class="fu">!</span>instr <span class="fu">=</span>
 modify <span class="fu">$</span> \(<span class="dt">InstrState</span> set pc) <span class="ot">-&gt;</span> <span class="dt">InstrState</span> (set <span class="fu">&lt;&gt;</span> [instr]) (pc <span class="fu">+</span> <span class="dv">1</span>)
<span class="fu">...</span>
<span class="co">-- Output:</span>
<span class="co">-- &lt;&lt;infinite loop&gt;&gt;</span></code></pre></div>
<p>So we have our infinite loop. This concludes the post.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Huge thanks Enis Bayramoğlu for reviewing the whole post</li>
</ul>
    </section>
</article>
]]></description>
    <pubDate>Mon, 11 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://yigitozkavci.github.io/blog/posts/2018-06-11-recursive-do-jump.html</guid>
    <dc:creator>Yiğit Özkavcı</dc:creator>
</item>

    </channel>
</rss>
